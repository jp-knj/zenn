---
title: "アイランドアーキテクチャの設計と実装"
---

第1章ではJavaScript肥大化という課題を位置付け、その解決策の方向性として"送るコードを減らす"思想を確認しました。本章では、その思想を具体的な形にした **アイランドアーキテクチャ** を、設計の意図からビルド・ランタイムの内部処理まで通しで解説します。読み終えたときには、Astroが高速性と柔軟性を両立するために取った設計判断が、コードレベルで腹落ちしていることを目指します。

## 章の目的

1. アイランドアーキテクチャが採用された理由とメリットを理解する。
2. ビルド時に静的HTMLと島のプレースホルダーを生成する仕組みを把握する。
3. ランタイムが選択的ハイドレーションを行う流れを追体験する。
4. 他フレームワークのアプローチと比較し、性能制御の違いを整理する。

## 1. なぜ"島"に分割するのか

従来のSPAでは、インタラクティブかどうかにかかわらずページ全体が1つのJavaScriptアプリとして扱われます。その結果、ユーザーが最初に見るべきコンテンツが大量のスクリプト解析を待たされるという本末転倒が生じていました。アイランドアーキテクチャはこの状況を逆転させます。まず静的なHTMLの "海" を即座に描画し、後から必要な部分だけを独立した "島" としてハイドレーションする。こうすることで表示の初速を確保しつつ、動的な振る舞いも失わない――ここに最大の利点があります。

加えて、島ごとに実行環境を切り分けるため、広告ウィジェットなど重いロジックの影響を記事本文に波及させずに済みます。JavaScriptが無効な環境でも基本情報は読めるというProgressive Enhancementの原則も、自動的に満たされます。

## 2. 静的 HTML と設計図を出力する

ビルドフェーズでは、Astroコンパイラがすべてのコンポーネントをサーバーサイドでレンダリングし、ページ全体をHTMLとして書き出します。`client:*` ディレクティブが付いたコンポーネントを検出すると、コンパイラは2つの仕事を行います。

* 該当コンポーネントと依存ライブラリを独立したJavaScriptファイルにバンドルする。
* 元の位置に `<astro-island>` 要素を挿入し、島の設計図を属性としてシリアライズする。

`<astro-island>` の属性にはコンポーネントURL、レンダラー URL、プロパティ、ハイドレーション戦略など必要な情報が格納されます。タグ内部にはサーバーが描いた初期HTMLがそのまま残るため、JavaScriptが未読込でもレイアウトが確定し、CLSを抑えられます。

// codewalk

## 3. 選択的ハイドレーションを実行する

ブラウザにHTMLを描画した直後、わずか数キロバイトのAstroランタイムが動き始めます。役割はシンプルで、ページ内の `<astro-island>` を走査し、`client` 属性に従ってハイドレーションのタイミングを決定することです。

`client="load"` が付いたナビゲーションはページ読み込みと同時に動作し、`client="visible"` が付いたカルーセルはIntersectionObserverで画面内に入るまでJavaScriptのフェッチを遅延します。こうしてリソースをファーストビューに不要な順に後回しにし、体感速度を高めています。

// codewalk

## 4. 他アーキテクチャとの比較

Next.js (App Router) ではサーバーコンポーネントを採用し、`'use client'` ディレクティブでクライアント側の境界を宣言します。一方、Astroのアイランドはページ上の任意の要素を島として切り出し、`client:*` ディレクティブでハイドレーション条件を指定します。どちらも"必要な場所にだけJavaScriptを届ける"という目標を共有しており、設計の単位とAPIが異なるだけです。

### 粒度と責務の違い

* **Astro**: UIの断面を島として分離し、React・Vue・Svelteなど複数フレームワークをページ単位で共存させられます。
* **Next.js**: Reactに特化し、コンポーネント階層で"サーバー / クライアント"の境界を分けるアプローチを取ります。

### 選定時の観点

| 観点           | Astro                                 | Next.js (App Router)             |
| ------------ | ------------------------------------- | -------------------------------- |
| UI フレームワーク混在 | ページ内で複数フレームワークを利用可能                   | React に最適化                       |
| ルーティング       | 静的生成 + SSR オプション                      | 動的ルーティングと SSR を標準装備              |
| ハイドレーション宣言   | `client:*` ディレクティブ                    | `'use client'`                   |
| データ取得        | Content Collections, `getStaticPaths` | React Server Components, `fetch` |

両者は"必要な箇所にだけコードを送る"という同じ課題に対する異なる解法です。規模感、チームの技術スタック、SEO要件など複数軸で評価し、単純な軽重比較ではなく、プロジェクトに適した選択を行うことが現実的です。

## 5. まとめと次章への橋渡し まとめと次章への橋渡し

アイランドアーキテクチャは"表示を急ぎ、動作を遅らせる"戦略をコードレベルで形にしたものです。ビルド時に静的HTMLと設計図を生成し、ランタイムで必要最小限のJavaScriptを段階的に読み込む。この二段構えがAstroの高速性の土台にあります。

次章では、複数のUIフレームワークを1つのページに共存させるAstroのレンダラーシステムを掘り下げ、React・Vue・Svelteがどのように同居して動くのかを解明します。
