---
title: "Astroの設計思想と誕生の背景"
---

Astroは"必要なJavaScriptだけを届ける"という明快な目標を掲げて誕生しました。本書では、その内部構造と設計判断を自作するつもりで分解し、読み手が自らのコードに置き換えて再現できるレベルまで掘り下げていきます。第1章はAstroが生まれた背景と根底にある思想を整理します。

この章を読み終えるころには、Astroの各機能が単なる実装上の都合ではなく、歴史的経緯と課題解決の必然から導かれたものであることが見えてくるはずです。

## はじめに

サーバーで静的領域を生成し、動的領域にplaceholderを置き、クライアントで個別ハイドレートし、動的領域は同士は独立します。

ページ全体を静的領域の"海"と動的領域の"島"に分割する考え方になります。
サーバーが送り出すHTMLは即座に描画されます。ユーザーは待ち時間なく読み始めます。一方で島となる動的領域は、必要になった瞬間だけJavaScriptによって動き出します。

## なぜ、Islands が必要だったのか

2020年前後、ReactやVueが成熟し、シングルページアプリケーション (SPA) が標準解のように扱われる一方で、初期ロードに必要なバンドルが肥大化し続けていました。モバイル環境では特に顕著で、数Mバイト規模のJavaScriptがネットワーク帯域とバッテリーを圧迫し、ユーザー体験を犠牲にしていました。

SSRやSSGを導入したNext.jsやGatsbyも、最終的にはページ全体をハイドレートするために大量のJavaScriptを必要とする構造から抜け出せませんでした。"最適化されているはずの静的サイトが、なぜこんなにJSを抱えているのか"という疑問が、多くの開発者で共有され始めた時期でもあります。

> ハイドレート対象 = 送る JS 量

ViteやBunがどれだけビルドと実行を速くしても、"DOM全体をReact/Vueが取り込んで再描画する"というSPA型ハイドレーションを選ぶ限り、ブラウザには依然としてフレームワーク本体＋ページ単位のJSが届きます。結果として実行時メモリやCPU利用率は高止まりし、モバイル体験のボトルネックを取り除けません。
Viteが得意なのは"ビルド時間と開発者体験の高速化"であって、生成されるバンドル総量やクライアントのハイドレーション負荷は、採用するUIフレームワークの構造（完全ハイドレーションか部分ハイドレーションか）に依存します

## 着想 - Snowpack

Preact作者のJason MillerはブログでIslands Architectureを提示した。彼は、"まずHTMLを送り、必要な部位だけを後からハイドレートする"という逆転の発想で、モバイル体験を劇的に軽くする道筋を示した。

同じ頃、Fred SchottがSnowpackというESMベースのビルドツールを公開した。開発中はバンドラーを介さず、ブラウザがネイティブモジュールを直接読む――この実験は"不要な変換を減らすことで開発も本番も速くなる"ことを証明し、のちにAstroの発想へと結実する。

## Astro の三つの設計原則

Astroの公式サイト"Why Astro?"に掲げられる三原則は次のとおりです。

* **コンテンツ中心** : MarkdownやCMSから取得したデータを第一級市民として扱い、UIロジックよりも優先する。
* **サーバーファースト** : 可能な限りの処理をサーバーで完了させ、クライアントは本当に必要な瞬間までJavaScriptをダウンロードしない。
* **デフォルトで高速** : 特別な設定を追加しなくても、高速なサイトが手に入ることを前提にする。

この方針を支える具体的な仕組みが、`client:*` ディレクティブを介した選択的ハイドレーションです。開発者が明示的に指示しない限り、コンポーネントのJavaScriptは出力されず、HTMLのみを配信します。

## 同時代フレームワークとの対話と Astro の立ち位置

React Server Componentsが掲げる"送るJSの削減"、Remixが推進するProgressive Enhancement、Qwikが実装するResumability――どれも過剰なハイドレーション負債からの脱却を目指している。しかしAstroは早期に"まず静的HTMLを届け、必要な部分だけ動的化する"という単純かつ実用的な解を提示した点で際立つ。皆同じ問題を別解で解いてるように見える。

## まとめと次章への橋渡し

JavaScript肥大化がもたらした問題から出発し、アイランドアーキテクチャを核とするAstroの設計思想を概観しました。ここで得た歴史的背景と三原則を頭に置くことで、次章以降の技術解説が"なぜそうするのか"という問いに自然と紐づくはずです。次章では、アイランドアーキテクチャをどのようにコードで実装し、ビルド時に静的HTMLとプレースホルダーを生成するのかを具体的に見ていきます。
