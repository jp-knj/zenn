---
title: "Astroの設計思想とIslands Architecture"
---

## はじめに

Astroの強さの正体とは、なんでしょうか。私は問い直すことがあります。

初期表示の速さが印象的でした。ビルドされたページは静的なHTMLとして即座に描画されます。インタラクティブな部分も滑らかに表示されます。重いライブラリを読み込む場面が少ない。ネットワークが混雑していても軽やかに動きます。

この"速さ"はいったいどこから来るのでしょうか。

最新のアルゴリズムが使われているわけではありません。ReactやVueのように革新的な状態管理モデルを備えているわけでもありません。むしろAstroは、技術の足し算ではなく、引き算の思想に徹した設計を選びました。

機能を減らす。JavaScriptを送らない。ページ全体を再構築しない。必要な箇所にだけ、必要な最小のコードを送る。この一見素朴とも思える方針が、なぜこれほどまでに効果的だったのでしょうか。

本章では、その問いを入り口に、Astroの設計思想とそれが生まれた時代的背景をたどっていきます。Astroを一度バラバラに分解し、あなた自身の手で再び組み立てる。その過程を通じて、"なぜこの選択がなされたのか"を追体験していきます。

> 私たちは、本当に「すべての場所にJavaScriptが必要なのか」を問い直すことから始めなければなりませんでした。


## JavaScript肥大化の時代

2020年ごろ、多くの開発者がある感覚を抱いていました。"最適化しているはずなのに、ページが遅い"

GoogleのAddy Osmaniは、2018年に発表した [The Cost of JavaScript](https://v8.dev/blog/cost-of-javascript-2018) において、  
JavaScriptは"ダウンロードされてから実行されるまでのすべての工程で、CPUに重い負荷を与えるリソース"であると指摘しました。

とくにローエンド端末では、わずか1MBのJavaScriptを読み込むだけで数秒の初期化時間が発生します。これは、HTMLやCSSが即座に表示されるのと対照的です。

```ts
// 図1: モバイル端末における JavaScript 実行コスト（2019年 Chrome DevTools 実測）
Download: 約 200ms（4G回線）
Parse/Compile: 約 1,100ms
Execute: 約 1,500ms
Total: 約 2,800ms
````

つまり、JavaScriptは読み込んだ直後から、画面の操作性を数秒単位で遅らせる原因となり得るのです。

さらに [Web Almanac 2020](https://almanac.httparchive.org/en/2020/page-weight/#page-weight) は、 モバイルページのJavaScript転送量の中央値が450KBに達していることを報告しました。

これはテキストベースのHTML（30〜50KB）やCSS（100〜150KB）と比べて、圧倒的に大きな割合を占めていることになります。

この負荷は、体感にも直結します。2020年、Googleは新たにINP（Interaction to Next Paint）という指標をCore Web Vitalsに導入しました。
INPは"ユーザーがタップやクリックなどの操作をしてから、画面が実際に反応するまでの時間"を測るもので、ユーザー体験そのものを測る指標です。

ページが"表示されたように見えても、操作すると反応しない"。そのような現象は、ページ全体をJavaScriptで制御する設計によって引き起こされていました。

> いかに速く表示されても、操作できなければ「使えるページ」とは言えない。
> INP の登場は、そうした根源的なズレを可視化する契機となったのです。

もちろん、[web.dev](https://web.dev/articles/reduce-javascript-payloads-with-tree-shaking) にあるように、
Tree Shakingやコード分割、遅延読み込みといった技術は、改善の努力として重ねられてきました。

しかし、それでもJSを"ページ全体"に載せる前提が残っていれば、どれだけ圧縮しても、必要以上に多くのJavaScriptがブラウザに届く構造は変わりません。

Astroは、まさにこの"構造の前提"そのものを疑ったのです。送る量を減らすのではなく、"そもそも送らない"ことを基準に再設計する。

その発想の転換が、次に登場するIslands Architectureでした。

## なぜ、Islands が必要だったのか

2020年前後、ReactやVueが成熟し、シングルページアプリケーション (SPA) が標準解のように扱われる一方で、初期ロードに必要なバンドルが肥大化し続けていました。モバイル環境では特に顕著で、数Mバイト規模のJavaScriptがネットワーク帯域とバッテリーを圧迫し、ユーザー体験を犠牲にしていました。

SSRやSSGを導入したNext.jsやGatsbyも、最終的にはページ全体をハイドレートするために大量のJavaScriptを必要とする構造から抜け出せませんでした。"最適化されているはずの静的サイトが、なぜこんなにJSを抱えているのか"という疑問が、多くの開発者で共有され始めた時期でもあります。

> ハイドレート対象 = 送る JS 量

ViteやBunがどれだけビルドと実行を速くしても、"DOM全体をReact/Vueが取り込んで再描画する"というSPA型ハイドレーションを選ぶ限り、ブラウザには依然としてフレームワーク本体＋ページ単位のJSが届きます。結果として実行時メモリやCPU利用率は高止まりし、モバイル体験のボトルネックを取り除けません。
Viteが得意なのは"ビルド時間と開発者体験の高速化"であって、生成されるバンドル総量やクライアントのハイドレーション負荷は、採用するUIフレームワークの構造（完全ハイドレーションか部分ハイドレーションか）に依存します

## 着想 - Snowpack

Preact作者のJason MillerはブログでIslands Architectureを提示した。彼は、"まずHTMLを送り、必要な部位だけを後からハイドレートする"という逆転の発想で、モバイル体験を劇的に軽くする道筋を示した。

同じ頃、Fred SchottがSnowpackというESMベースのビルドツールを公開した。開発中はバンドラーを介さず、ブラウザがネイティブモジュールを直接読む――この実験は"不要な変換を減らすことで開発も本番も速くなる"ことを証明し、のちにAstroの発想へと結実する。

## Astro の三つの設計原則

Astroの公式サイト"Why Astro?"に掲げられる三原則は次のとおりです。

* **コンテンツ中心** : MarkdownやCMSから取得したデータを第一級市民として扱い、UIロジックよりも優先する。
* **サーバーファースト** : 可能な限りの処理をサーバーで完了させ、クライアントは本当に必要な瞬間までJavaScriptをダウンロードしない。
* **デフォルトで高速** : 特別な設定を追加しなくても、高速なサイトが手に入ることを前提にする。

この方針を支える具体的な仕組みが、`client:*` ディレクティブを介した選択的ハイドレーションです。開発者が明示的に指示しない限り、コンポーネントのJavaScriptは出力されず、HTMLのみを配信します。

## 同時代フレームワークとの対話と Astro の立ち位置

React Server Componentsが掲げる"送るJSの削減"、Remixが推進するProgressive Enhancement、Qwikが実装するResumability――どれも過剰なハイドレーション負債からの脱却を目指している。しかしAstroは早期に"まず静的HTMLを届け、必要な部分だけ動的化する"という単純かつ実用的な解を提示した点で際立つ。皆同じ問題を別解で解いてるように見える。

## まとめと次章への橋渡し

JavaScript肥大化がもたらした問題から出発し、アイランドアーキテクチャを核とするAstroの設計思想を概観しました。ここで得た歴史的背景と三原則を頭に置くことで、次章以降の技術解説が"なぜそうするのか"という問いに自然と紐づくはずです。次章では、アイランドアーキテクチャをどのようにコードで実装し、ビルド時に静的HTMLとプレースホルダーを生成するのかを具体的に見ていきます。

[1]: https://gitnation.com/contents/making-bite-sized-web-games-with-gamesnacks "Making “Bite-Sized” Web Games with GameSnacks by Alex Hawker"
[2]: https://web.dev/articles/reduce-javascript-payloads-with-tree-shaking "Reduce JavaScript payloads with tree shaking  |  Articles  |  web.dev"
