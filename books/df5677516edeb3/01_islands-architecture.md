---
title: "Astroの設計思想とIslands Architecture"
---

## はじめに

Astroの強さの正体とは、なんでしょうか。私は問い直すことがあります。

初期表示の速さが印象的でした。ビルドされたページは静的なHTMLとして即座に描画されます。インタラクティブな部分も滑らかに表示されます。重いライブラリを読み込む場面が少ない。ネットワークが混雑していても軽やかに動きます。

この「速さ」はいったいどこから来るのでしょうか。

最新のアルゴリズムが使われているわけではありません。ReactやVueのように革新的な状態管理モデルを備えているわけでもありません。むしろAstroは、技術の足し算ではなく、引き算の思想に徹した設計を選びました。この一見素朴とも思える方針が、なぜこれほどまでに効果的だったのでしょうか。

本章では、その問いを入り口に、Astroの設計思想とそれが生まれた時代的背景をたどっていきます。Astroを一度バラバラに分解し、あなた自身の手で再び組み立てる。その過程を通じて、"なぜこの選択がなされたのか"を追体験していきます。

> 私たちは、本当に「すべての場所にJavaScriptが必要なのか」を問い直すことから始めなければなりませんでした。


## JavaScript肥大化の時代

2020年ごろ、多くの開発者がある感覚を抱いていました。「最適化しているはずなのに、ページが遅い」

GoogleのAddy Osmaniは、2018年に発表した [The Cost of JavaScript](https://v8.dev/blog/cost-of-javascript-2018) で興味深い発言があります。JavaScriptは「ダウンロードされてから実行されるまでの工程で、CPUに重い負荷を与えるリソース」であると指摘しました。

とくに低価格帯のAndroid端末では、わずか1MBのJavaScriptを読み込むだけで数秒の初期化時間が発生します。これは、HTMLやCSSが即座に表示されるのと対照的です。

```ts
// 図1: モバイル端末における JavaScript 実行コスト（2019年 Chrome DevTools 実測）
Download: 約 0.2ms（4G回線）
Parse/Compile: 約 1,1秒
Execute: 約 1,5秒
Total: 約 2,8秒
````

つまり、JavaScriptは読み込んだ直後から、画面の操作性を数秒単位で遅らせる原因となり得るのです。さらに [Web Almanac 2020](https://almanac.httparchive.org/en/2020/page-weight/#page-weight) は、モバイルページのJavaScript転送量の中央値が450KBに達していることを報告しました。これはテキストベースのHTML（30〜50KB）やCSS（100〜150KB）と比べて、圧倒的に大きな割合を占めていることになります。

この負荷は、体感にも直結します。2020年、Googleは新たにINP（Interaction to Next Paint）という指標をCore Web Vitalsに導入しました。INPは「ユーザーがタップやクリックなどの操作をしてから、画面が実際に反応するまでの時間」を測るもので、ユーザー体験そのものを測る指標です。

ページが「表示されたように見えても、操作すると反応しない」。そのような現象は、ページ全体をJavaScriptで制御する設計によって引き起こされていました。

> いかに速く表示されても、操作できなければ「使えるページ」とは言えない。
> INP の登場は、そうした根源的なズレを可視化する契機となったのです。

もちろん、[web.dev](https://web.dev/articles/reduce-javascript-payloads-with-tree-shaking) にあるように、Tree Shakingやコード分割、遅延読み込みといった技術は、改善の努力として重ねられてきました。しかし、それでもJSを「ページ全体」に載せる前提が残っていれば、どれだけ圧縮しても、必要以上に多くのJavaScriptがブラウザに届く構造は変わりません。

Astroは、まさにこの「構造の前提」そのものを疑ったのです。送る量を減らすのではなく、「そもそも送らない」ことを基準に再設計する。

その発想の転換が、次に登場するIslands Architectureでした。

## 発想の転換でIslands Architectureの登場

Preactの開発者、Jason Millerが示した「Islands Architecture（アイランズ・アーキテクチャ）」という概念です。これは、技術的にはごくシンプルなものでした。ページ全体をJavaScriptで制御するのではなく、まずは静的なHTMLを描き出し、インタラクティブ性が本当に必要な部分だけをIsland（Island）として動的に扱うという構造です。

この考え方は、ReactのようなSPAとは対極にあります。

従来のSSR（サーバーサイドレンダリング）では、HTMLを生成しても、そのすべてをJavaScriptで「復元（ハイドレート）」する必要がありました。Islands Architectureはその前提を破ります。動かすべき場所だけを選び、それ以外は動かさない。

ただし、「Island」という発想そのものは、まったく新しいものではありません。かつての `<iframe>` や `<embed>` もまた、ページ内に機能的に独立した“領域”を切り出す仕組みとして存在していました。それらは、地図、動画、掲示板などの動的コンテンツを「囲い込む」方法として、90年代からWebに組み込まれていたのです。

Jason Millerの提案は、それを現代的なコンポーネント単位にまで引き寄せた再発明であったと言えるでしょう。かつてのIslandが「外部のものを埋め込む」ためのものであったのに対し、Islands Architectureは静的なページの中で対話性を局所化するための構造へと昇華されました。

この設計思想は、Webの原初的な構造「HTMLを中心に据えること」への回帰でもあります。

その頃、ESM（ECMAScript Modules）をベースにしたSnowpackという実験的なビルドツールが登場していました。その作者Fred K. Schottは、Islands Architectureの考え方に強く惹かれます。そして彼は、Snowpackの次のプロジェクトとして、この構造を思想として最初から持ったフレームワークを構築することになります。

それが、Astroでした。

彼は後にこう語っています。ブログのようなコンテンツ中心サイトに、アプリケーション指向のフレームワークを適用すること自体がパフォーマンスの負債でした。

この言葉は、開発体験を重視する風潮が強かった当時にあって、異質な響きを持っていました。Webは、アプリケーションではなく、コンテンツのためのメディアであるべきでした。

この再定義は、まさにフロントエンドの設計哲学そのものへの問い直しでもあったのです。

## 他フレームワークとの対比：立ち位置の違いを描く

Astroの設計思想をより深く理解するために、他のフレームワークとの対比を見てみましょう。これは優劣ではなく、それぞれが解決しようとする問題の違いです。

私たちが比較に用いる視点は4つあります。初期ロードで届くJavaScriptのバイト数、インタラクティブ化の粒度、状態共有モデル、そしてビルド時と実行時の責務分担です。これらの軸で見ることで、「送らないJavaScript」という思想がどのように実装されているかが明確になります。

### React / Next.js：Server Componentsで脱・全体ハイドレーションへ

ReactチームもJavaScriptの過剰な配信に気づいていました。Server Componentsの導入により、従来の全体ハイドレーションから脱却し始めています。公式発表によれば、初期JavaScriptを従来比で4分の1程度まで削減できるケースもあるとのことです。

しかし、根本的な設計思想は変わっていません。ページ全体をReactツリーとして管理し、状態を一元的に制御する。この構造は残したまま、サーバーでレンダリングしたコンポーネントをクライアントに送らないという工夫を加えたのです。最小テンプレートでも46KB程度のJavaScriptが必要で、コンポーネント単位でのハイドレーションが基本となります。

### Vue 3：部分ハイドレーションをコアに統合予定

VueConf US 2024で、Evan You氏は興味深い発表をしました。Partial HydrationをVueのコアに統合するというロードマップです。これはIslands Architectureに近い考え方で、アプリケーションファーストのフレームワークでも、送るJavaScriptを劇的に削減しようという動きです。

現在のVue 3では、Viteを使った最小構成で約21KBのJavaScriptが必要です。将来的にはコンポーネント分割とIslandの概念を組み合わせた、柔軟な粒度でのハイドレーションが可能になる見込みです。

### Qwik：Resumabilityで1KBスタート

Qwikの発想はより革新的でした。ハイドレーションという概念そのものを捨て、「Resumability（再開可能性）」という新しいアプローチを提案しました。サーバーでシリアライズした状態をクライアントで「再開」することで、初期JavaScriptをわずか1KBまで削減しています。

インタラクティブ化はイベント発火時まで遅延され、必要な部分だけが動的にロードされます。これは極めて効率的ですが、依然としてJavaScript中心の世界観で構築されています。

### Remix：HTML強化とキャッシュ戦略でアプリを再定義

Remixはプログレッシブエンハンスメントの現代版とも言える設計を選びました。フォーム送信とキャッシュ制御をサーバーサイドで完結させ、JavaScript無効環境でも動作するアプリケーションを目指しています。

初期JavaScriptは20KB前後と軽量ですが、ルーティングやデータ読み込みは依然としてアプリケーション指向です。HTMLを強化するという思想は素晴らしいものの、動的アプリケーションを前提とした設計であることに変わりはありません。

### Astro：静的HTMLを基点に「Island」で局所ハイドレーション

これらのフレームワークと比較すると、Astroの立ち位置がより鮮明になります。初期JavaScriptは0KB。完全に静的なページとして配信され、`client:*`ディレクティブで明示的に指定した部分だけがインタラクティブな「Island」となります。

状態共有はIslandごとに独立しており、Island間でリアルタイムに状態を同期する場合は、開発者が明示的に外部ストアを組み込む必要があります。これは制約でもありますが、同時に「不要なJavaScriptを送らない」という原則を徹底した結果でもあります。

### 定量的な視点で見る差異

2024年のWeb Almanacによれば、モバイルサイトのJavaScriptペイロード中央値は558KBに達しています。これに対し、Astroは0KB、Qwikは1KB、Vue/Reactは20〜50KB、標準的なSPAは100KB以上。この「送らない度合い」の差は、実際のユーザー体験に直結します。

## 使い分けの指針

それぞれのフレームワークが目指す「速さ」の形は異なります。読むことが中心のブログやドキュメントサイトでは、Astroが最小コストで最高のパフォーマンスを発揮します。イベント駆動だが軽量なアプリケーションならQwikが優位です。複雑なSPAや企業ダッシュボードには、依然としてReactやVueが適しています。フォーム主体でSEOとキャッシュを重視するならRemixという選択肢もあるでしょう。

Astroは、これらの中で「HTMLを第一級市民に戻す」という立場を最も早く、最も徹底して選んだフレームワークです。その割り切りが、コンテンツ中心のサイトにおける圧倒的なパフォーマンスを実現しました。

## まとめ

私たちはこの章で、Astroの強さの正体を探ってきました。それは技術的な革新ではなく、設計思想の革新でした。JavaScript肥大化という時代の課題に対して、「そもそも送らない」という根本的な発想の転換。Islands Architectureという解決策。そして、コンテンツ中心・サーバーファースト・デフォルトで高速という3つの原則。

これらの思想は、実際のコードとして、具体的な実装として形にされて初めて、その価値を発揮します。

では、Astroはこの思想をどのようにコードで実現しているのでしょうか。静的なHTMLを生成し、必要な部分だけを「Island」として切り出す。この一見シンプルな仕組みの裏側には、精緻に設計されたコンパイラが存在します。

次章では、いよいよ手を動かし始めます。`.astro`ファイルという独特な構文を持つファイルを、コンパイラはどのように理解し、解析するのか。フロントマター、HTML、JavaScript式が混在する複雑な構造を、どのようにして抽象構文木（AST）へと変換するのか。

私たちは、Astroのパーサーを一から実装することで、その仕組みを体験的に理解していきます。正規表現とステートマシンを組み合わせた解析ロジック。境界の検出。コンポーネント参照の解決。これらの実装を通じて、前章で見た設計思想が、具体的なコードとしてどのように実現されているかを深く掘り下げていきます。
