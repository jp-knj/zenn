---
title: "View TransitionでわかるNext.jsとAstroの設計思想"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Next.js", "Astro"]
published: false
---

## はじめに

ウェブフロントエンド開発のエコシステムは成熟期を迎えました。長らくウェブ開発の議論を二分してきた「シングルページアプリケーション（SPA）」と「マルチページアプリケーション（MPA）」という二項対立は、View Transition APIの標準化と普及により、その境界線を溶解させています。

View Transition APIは、ページ遷移、要素の更新などのDOMの状態変化をブラウザがキャプチャし、新旧の状態間を補間するアニメーションを提供します。これにより、MPAであってもSPAのようなシームレスな体験を実装でき、SPAにおいては複雑なアニメーションライブラリに依存せず、宣言的な遷移アニメーションが実現できます。

この記事ではNext.js（App Router）とAstroに焦点を当て、各フレームワークがView Transition APIをどのように実装して統合しているかを解説します。View Transition APIという共通のレンズを通し、React Server Components（RSC）による「状態駆動型」と、Islands Architectureによる「DOM駆動型」、それぞれの根本的なアーキテクチャ思想の差異を明らかにすることをこの記事の目的とします。

## View Transition APIの動作原理

各フレームワークの実装に踏み込む前に、基盤となるブラウザのメカニズムを整理しましょう。これは単なるCSSアニメーションの拡張ではなく、ブラウザのレンダリングパイプラインへの深い介入です。

https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API

View Transition APIの核となるのは、[document.startViewTransition()](https://drafts.csswg.org/css-view-transitions-1/#customizing) です。このメソッドが呼び出されると、ブラウザはレンダリングループを一時停止し、厳密なステップを踏みます。

1. Capture: 現在の画面を画像としてキャプチャします。view-transition-nameを持つ要素は個別のレイヤーとして切り出されます。

2. Freeze: レンダリングを凍結し、ユーザーにはキャプチャしたスナップショットを表示し続けます。

3. Update: コールバック関数を実行し、DOMの更新（ページ遷移や要素の書き換え）を完了させます。

4. Recapture: 更新後の新しい画面（新しい状態）をキャプチャします。

5. Animate: 新しいスナップショットと古いスナップショットの間でアニメーションを実行します。CSSに基づいてクロスフェードや位置移動のアニメーションを実行します。

## AstroのDOM駆動アプローチ

AstroはIslands Architectureを標榜し、デフォルトでJavaScriptを排除するHTMLファーストのフレームワークです。Astroで作られたサイトは典型的なMPAです。なので、ページ遷移は「ドキュメントの破棄と再読み込み」を意味します。

しかし、View Transition APIをサポートするために導入された `<ClientRouter />`（旧 `<ViewTransitions />`）コンポーネントは、この前提を覆します。AstroのView Transition APIは「MPAのふりをしたSPA」にすることなのです。では、なぜAstroはわざわざSPAのようなルーターを導入したのでしょうか。そこには、View Transition APIの仕様における2つモードが関係しています。

### 実は2つある、View Transition APIのモード

View Transition APIには、仕様上明確に異なる2つのモードが存在します。

まずはLevel 1です。これは、Same-Document View Transitionsと呼ばれています。単一のドキュメント内でDOMを書き換えるモードです。SPAでの利用が想定されています。JavaScriptでAPIを呼び出し、コールバック内でDOMを更新します。ブラウザはページ遷移と認識しないため、JavaScriptの状態は維持されます。

その次にLevel 2です。Cross-Document View Transitionsと呼ばれています。異なるドキュメント間を遷移するモードです。MPAでの利用が想定されています。CSSのみで有効化できますが、遷移中の細かい制御や複雑な状態の引継ぎには制約があります。

本来MPAであるAstroはLevel 2と相性が良いはずです。しかし、Level 2はまだ仕様策定や実装の途上にあります。そこでAstroは、「MPAのふりをしたSPA」として振る舞うというプラグマティックな道を選びました。

<ClientRouter />がリンクのクリックをインターセプトし、fetchでHTMLを取得して書き換えることで、擬似的にLevel 1の環境を作り出しています。これにより、MPAの手軽さを保ちつつ、SPA並みのリッチな制御しているのです。

### transition:persist によるDOMのスワップ

この擬似的なSPA化において、Astroが提供する機能が `transition:persist` です。通常、bodyを入れ替えれば `<video>` の再生位置や `<canvas>` の描画内容はリセットされます。これを防ぐため、AstroはDOMノードの物理的なスワップを行います。

スワップ直前、対象のDOMノードを現在のツリーから切断し、メモリ上に退避させます。この時点でノードはドキュメントから外れますが、JavaScriptインスタンスとしては生きており、内部状態を保持します。新しいHTMLが挿入された後、対応するプレースホルダーを、退避させておいた「生きたDOMノード」でスワップします。

これはReactのような差分検知とは根本的に異なります。Reactが「状態を維持してビューを再描画」するのに対し、Astroは「物理的な要素そのものを移動」させます。これにより、フレームワーク固有の状態管理に依存せず、ブラウザネイティブの状態を維持できます。

## Next.js (App Router) における状態駆動のアプローチ

Next.js (App Router) におけるView Transition APIの実装は、DOMの直接操作ではなく、ReactのレンダリングサイクルおよびReact Server Components (RSC) と密接に統合されています。

### RSC Payloadによる論理的な差分更新

Next.jsのナビゲーションにおいて、クライアントは新しいHTMLではなく、RSC Payloadと呼ばれるシリアライズされたコンポーネントデータを受け取ります。Reactのランタイムはこのデータを解析し、現在のコンポーネントツリーに対する差分のみを適用します。AstroがDOMの物理的な置換を行うのに対し、Next.jsはReactの状態管理に基づいた差分のみの更新を行います。

### StreamingとSuspenseにおける表示タイミングの制御

Next.jsのApp Routerは、StreamingとSuspenseを利用してコンテンツを段階的にレンダリングします。しかし、View Transition APIは「遷移完了後の画面」へのアニメーションを前提としているため、段階的なレンダリングとは競合できます。データ取得が完了していない段階で画面遷移を行うと、アニメーション終了直後にローディング表示が出現し、その後コンテンツが表示されるという不自然な体験になります。

この課題に対し、ReactとNext.jsは `useViewTransition` フックを利用して制御を行います。Reactは「一時停止」を検知できるため、次の画面の主要なコンテンツが準備できるまで現在の画面を維持し、準備が整った段階でView Transitionを開始します。これにより、ローディング状態をスキップして完成された画面へ遷移させる等の制御できます。

### Reactの同時実行性とブラウザAPIの同期要件

技術的な課題として、Reactの同時実行性（Concurrency）とView Transition APIの同期性の不一致が挙げられます。ブラウザのAPIは、DOM更新を行うコールバック関数が同期的に完了することを期待しています。一方、Reactのレンダリングは非同期であり、中断や優先順位の変更が発生してもおかしくないのです。

Reactがレンダリングを中断しているとき、ブラウザが画面のキャプチャを行えば、不完全な状態が描画されてしまいます。これを防ぐため、Next.js環境下のReactは、View Transitionに関連する更新処理において、React Elementへの書き込み（コミットフェーズ）をブラウザのコールバック関数内で同期的かつ即座に実行するように動作を変更します。Next.jsはブラウザ標準APIをそのまま利用するのではなく、Reactのランタイム動作の一部として統合し、厳密に管理しています。

## 最後に

AstroとNext.jsは、同じView Transition APIを利用しながらも、そのアプローチは大きく異なっていることが理解できたでしょうか。

Astroのアプローチは、将来的なWeb標準を見据えたポリフィルに近い性質を持ちます。DOMの置換と要素の永続化による実装は、ブラウザがCross-Document View Transitionsを完全にサポートしたときには、<ClientRouter />を削除しても動作する可能性が高い設計です。

対してNext.jsは、View TransitionをReactエコシステムの一部として取り込んでいます。SuspenseやServer ActionsといったReact固有の機能と協調させることで、高度な体験を提供しますが、これはWeb標準技術をReactのランタイム上で抽象化するアプローチと言えます。

開発者は、画面上のアニメーションだけでなく、その背後でDOMがどのように扱われ、状態がどのように管理されているかを理解することで、プロジェクトの要件に最適なフレームワークを選定することができるでしょう。
