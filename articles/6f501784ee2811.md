---
title: "View TransitionでわかるNext.jsとAstroの設計思想"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Next.js", "Astro"]
published: false
---

## はじめに

ウェブフロントエンド開発のエコシステムは成熟期を迎えました。長らくウェブ開発の議論を二分してきた「シングルページアプリケーション（SPA）」と「マルチページアプリケーション（MPA）」という二項対立は、View Transition APIの標準化と普及により、その境界線を溶解させています。

View Transition APIは、ページ遷移、要素の更新などのDOMの状態変化をブラウザがキャプチャし、新旧の状態間を補間するアニメーションを提供します。これにより、MPAであってもSPAのようなシームレスな体験を実装でき、SPAにおいては複雑なアニメーションライブラリに依存せず、宣言的な遷移アニメーションが実現できます。

@[stackblitz](https://stackblitz.com/edit/withastro-astro-9ffuqoiz?embed=1&file=src%2Fpages%2Findex.astro&view=preview)

他の[デモサイト](https://http203-playlist.netlify.app/)をさわって、インタラクティブなView Transitionを試してみましょう。

この記事ではNext.js（App Router）とAstroに焦点を当て、各フレームワークがView Transition APIをどのように実装して統合しているかを解説します。View Transition APIという共通のレンズを通し、React Server Components（RSC）による「状態駆動型」と、Islands Architectureによる「DOM駆動型」、それぞれの根本的なアーキテクチャ思想の差異を明らかにすることをこの記事の目的とします。

## View Transition APIの動作原理

各フレームワークの実装に踏み込む前に、基盤となるブラウザのメカニズムを整理しましょう。これは単なるCSSアニメーションの拡張ではなく、ブラウザのレンダリングパイプラインへの深い介入です。

https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API

View Transition APIの核となるのは、[document.startViewTransition()](https://drafts.csswg.org/css-view-transitions-1/#customizing) です。このメソッドが呼び出されると、ブラウザはレンダリングループを一時停止し、厳密なステップを踏みます。

1. Capture: 現在の画面を画像としてキャプチャします。view-transition-nameを持つ要素は個別のレイヤーとして切り出されます。

2. Freeze: レンダリングを凍結し、ユーザーにはキャプチャしたスナップショットを表示し続けます。

3. Update: コールバック関数を実行し、DOMの更新（ページ遷移や要素の書き換え）を完了させます。

4. Recapture: 更新後の新しい画面（新しい状態）をキャプチャします。

5. Animate: 新しいスナップショットと古いスナップショットの間でアニメーションを実行します。CSSに基づいてクロスフェードや位置移動のアニメーションを実行します。

## AstroのDOM駆動アプローチ

AstroはIslands Architectureを標榜し、デフォルトでJavaScriptを排除するHTMLファーストのフレームワークです。Astroで作られたサイトは典型的なMPAです。なので、ページ遷移は「ドキュメントの破棄と再読み込み」を意味します。

しかし、View Transition APIをサポートするために導入された [ClientRouter](https://docs.astro.build/en/guides/view-transitions/#differences-between-browser-native-view-transitions-and-astros-clientrouter-)（旧 `<ViewTransitions />`）コンポーネントは、この前提を覆します。

```js:index.astro
---
import { ClientRouter } from 'astro:transitions';
---
<html lang="ja">
  <head>
    <title>title</title>
    <ClientRouter />
  </head>
  <body>
    <h1>Astro Demo</h1>
    <a href="/page2">
      次のページへ
    </a>
  </body>
</html>
```

AstroのView Transition APIは「MPAのふりをしたSPA」にすることなのです。では、なぜAstroはわざわざSPAのようなルーターを導入したのでしょうか。そこには、View Transition APIの仕様における2つモードが関係しています。

### 実は2つある、View Transition APIのモード

View Transition APIには、仕様上明確に異なる2つのモードが存在します。

まずはLevel 1です。これは、[Same-Document View Transitions](https://drafts.csswg.org/css-view-transitions-1/#intro)と呼ばれています。単一のドキュメント内でDOMを書き換えるモードです。SPAでの利用が想定されています。JavaScriptでAPIを呼び出し、コールバック内でDOMを更新します。ブラウザはページ遷移と認識しないため、JavaScriptの状態は維持されます。

その次にLevel 2です。[Cross-Document View Transitions](https://drafts.csswg.org/css-view-transitions-2/#cross-document-view-transitions)と呼ばれています。異なるドキュメント間を遷移するモードです。MPAでの利用が想定されています。CSSのみで有効化できますが、遷移中の細かい制御や複雑な状態の引継ぎには制約があります。

本来MPAであるAstroはLevel 2と相性が良いはずです。しかし、Level 2はまだ仕様策定や実装の途上にあります。そこでAstroは、「MPAのふりをしたSPA」として振る舞うというプラグマティックな道を選びました。

`<ClientRouter />`がリンクのクリックをインターセプトし、fetchでHTMLを取得して書き換えることで、擬似的にLevel 1の環境を作り出しています。これにより、MPAの手軽さを保ちつつ、SPA並みのリッチな制御しているのです。

### transition:persist によるDOMのスワップ

この擬似的なSPA化において、Astroが提供する機能が `transition:persist` です。

https://x.com/astrodotbuild/status/1689742663116115969?s=20

通常、bodyを入れ替えれば `<video>` の再生位置や `<canvas>` の描画内容はリセットされます。これを防ぐため、AstroはDOMノードの物理的なスワップを行います。

スワップ直前、対象のDOMノードを現在のツリーから切断し、メモリ上に退避させます。この時点でノードはドキュメントから外れますが、JavaScriptインスタンスとしては生きており、内部状態を保持します。新しいHTMLが挿入された後、対応するプレースホルダーを、退避させておいた「生きたDOMノード」でスワップします。

これはReactのような差分検知とは根本的に異なります。Reactが「状態を維持してビューを再描画」するのに対し、Astroは「物理的な要素そのものを移動」させます。これにより、フレームワーク固有の状態管理に依存せず、ブラウザネイティブの状態を維持できます。

## Next.js (App Router) における状態駆動のアプローチ

Next.jsにおけるView Transitionは、ブラウザのネイティブAPIをそのまま使うのではなく、Reactの同時実行レンダリング（Concurrent Rendering）の中に、同期的なDOM更新を「埋め込む」ということで成立しています。

その構造は、大きく3つのフェーズで動作します。

#### HTMLではなく「RSC Payload」による論理更新

ナビゲーションがトリガーされると、Next.jsは新しいHTMLページを取得するのではなく、RSC Payload（シリアライズされたReact Server Componentsのデータ）を取得します。

  * **動作構造:**
    1.  サーバーでレンダリングされたコンポーネントツリーの差分データ（Payload）がクライアントに流れてくる。
    2.  クライアント上のReactランタイムがこれを解析（Deserialize）する。
    3.  既存の **Fiber Tree**（Reactの仮想DOMツリー）に対して、新しいサーバーデータをマージする。
  * **アーキテクチャ上の意味:**
    物理的なDOMの総入れ替えではなく、**メモリ上のツリー構造の論理的な接ぎ木（Grafting）** が行われます。これにより、動画の再生状態やフォームの入力値などの「クライアントの状態」が維持されます。

#### 非同期処理と表示タイミングの完全制御

View Transition APIは「遷移完了後の完成された画面」へのアニメーションを前提とします。しかし、Reactのレンダリング（特にStreamingやSuspenseを伴う場合）は非同期かつ段階的です。このギャップを埋めるのが`useTransition`です。

  * 動作構造:
    1.  ナビゲーション開始時、Reactは `isPending` 状態になり、バックグラウンド（メモリ上）で次の画面のレンダリング計算を開始する。
    2.  データ取得（Suspend）が完了し、**次の画面の描画準備が完全に整うまで、現在の画面（DOM）を一切変更せず維持する**。
    3.  準備完了のシグナルが出た瞬間に、次のフェーズ（コミット）へ移行する。

ブラウザが勝手に遷移を始めるのを防ぎ、Reactが「いつ遷移を開始するか」の全権限（Instruction）を持ちます。これにより「ローディングスピナーへの遷移」を防ぎます。

#### 3\. 実行層：非同期ランタイム内での「強制的同期コミット」

ここが最も技術的にクリティカルな部分です。ブラウザの `document.startViewTransition(callback)` は、`callback` 内でDOMが同期的に更新されることを要求します。

  * **動作構造:**
    1.  Reactは準備が整った新しいツリーをDOMに反映する際、通常（Concurrent Mode）の「優先度付き更新」を一時停止する。
    2.  `startViewTransition` のコールバック関数内で、**`flushSync` 相当の処理を実行し、強制的に同期的なDOMコミットを行う**。
    3.  これにより、ブラウザは「古いスナップショット」と「新しいスナップショット」の間にあるDOMの変化を、一瞬の空白もなく連続的にキャプチャできる。
  * **アーキテクチャ上の意味:**
    非同期で動くReactの世界と、同期を求めるブラウザAPIの世界を接続するための\*\*ブリッジ処理（同期化アダプター）\*\*がランタイムに組み込まれています。

-----


## 最後に

AstroとNext.jsは、同じView Transition APIを利用しながらも、そのアプローチは大きく異なっていることが理解できたでしょうか。

Astroのアプローチは、将来的なWeb標準を見据えたポリフィルに近い性質を持ちます。DOMの置換と要素の永続化による実装は、ブラウザがCross-Document View Transitionsを完全にサポートしたときには、`<ClientRouter />`を削除しても動作する可能性が高い設計です。

対してNext.jsは、View TransitionをReactエコシステムの一部として取り込んでいます。SuspenseやServer ActionsといったReact固有の機能と協調させることで、高度な体験を提供しますが、これはウェブ標準技術をReactのランタイム上で抽象化するアプローチと言えます。

開発者は、画面上のアニメーションだけでなく、その背後でDOMがどのように扱われ、状態がどのように管理されているかを理解することで、プロジェクトの要件に最適なフレームワークを選定することができるでしょう。
