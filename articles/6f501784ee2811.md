---
title: "View Transition APIを通じて見えてくるNext.jsとAstroのアーキテクチャ"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Next.js", "Astro"]
published: false
---

## はじめに

ウェブフロントエンド開発のエコシステムは、かつてないほどの成熟期を迎えています。長らくウェブ開発の議論を二分してきた「シングルページアプリケーション（SPA）」と「マルチページアプリケーション（MPA）」という二項対立は、View Transition APIの標準化と普及により、その境界線を急速に溶解させつつあるのではないでしょうか。

View Transition APIは、ページの遷移、要素の更新やDOMの状態変化をブラウザがキャプチャし、新旧の状態間を補完するアニメーションを提供します。これにより、MPAであってもSPAのようなシームレスな体験を提供できるようになり、SPAにおいては複雑なアニメーションライブラリに依存することなく、宣言的な遷移制御ができるのです。

この記事ではNext.js（App Router）とAstroに焦点を当て、それらがView Transition APIをどのように実装、統合しているかを見ていきます。
View Transition APIという共通のレンズを通して、両フレームワークの根本的なアーキテクチャ思想のReact Server Components（RSC）による「状態駆動型」のアプローチと、Islands Architectureによる「DOM駆動型」のアプローチ——の違いを浮き彫りにすることを目的としています。

## View Transition APIとは

Next.jsとAstroの実装を見る前に、その基盤となるブラウザのメカニズム、すなわちView Transition APIの仕様と動作原理を深く理解する必要があります。このAPIは単なるCSSの拡張ではなく、ブラウザのレンダリングに直接介入する低レベルのプリミティブです。

### ブラウザレンダリング

View Transition APIの核となるのは、`document.startViewTransition(callback)`メソッドです。このメソッドが呼び出されると、ブラウザはレンダリングループを一時停止し、厳密な手順を踏みます。

1. 古い画面のキャプチャ

ブラウザは現在のビューポートをラススタライズ（画像化）します。この際、view-transition-name CSSプロパティが付与された要素は個別にレイヤーとして切り出され、それ以外の部分は「root」スナップショットとしてキャプチャされます。この処理はメインスレッドとGPUプロセスが協調して行われ、現在の画面状態を完全に凍結します。

2. レンダリングの凍結

ユーザーには「旧状態」のスナップショットが表示され続けます。この間、ブラウザはバックグラウンドでDOMの更新を待機します。フレームワークはこのタイミングでDOMを変更する処理を実行します。後述しますが、Reactのステート更新やAstroのHTMLスワップです。

3. DOMの更新とコールバック実行

startViewTransitionに渡されたコールバック関数が実行されます。このコールバックはPromiseを返すことが期待されており、そのPromiseが解決されるまでブラウザは待機します。ここで重要なのは、DOMの更新が同期的に、あるいは極めて短時間に行われる必要があるという点です。非同期処理が長引けば、ユーザーは操作不能な凍結画面を見続けることになります。

4. 新しい画面のキャプチャ
コールバックが完了し、ブラウザが新しいDOMのレイアウト計算とペイントを終えると、再びラスタライズが行われます。これが「新状態」のスナップショットとなります。


5. 疑似要素ツリーの構築とアニメーション
ブラウザは::view-transitionをルートとする特別な疑似要素ツリーをHTML要素の上にオーバーレイとして生成します。このツリーには、旧スナップショット（::view-transition-old）と新スナップショット（::view-transition-new）が含まれます。デフォルトでは、これらがクロスフェード（opacityの遷移）しますが、CSSを用いて位置（transform）やサイズ（width/height）の遷移を定義することで、要素が移動しているような視覚効果を生み出します 2。

### Same-Document遷移とCross-Document遷移

仕様策定とブラウザ実装において、最も重要な区分が「Same-Document（単一ドキュメント）」と「Cross-Document（ドキュメント間）」の違いです。

機能区分技術的定義フレームワークの対応状況Same-Document View Transitions (Level 1)documentオブジェクトが破棄されず、JavaScriptによってDOMが書き換えられる遷移。SPAにおけるルーティング遷移がこれに該当します。Next.js (App Router), Astro (Client Routerモード) が主に使用。JavaScriptによるAPI呼び出し(document.startViewTransition)が必須。Cross-Document View Transitions (Level 2)ブラウザが新しいURLへナビゲートし、documentが破棄されて新しいdocumentがロードされる遷移。MPAの標準的な遷移。CSSの@view-transition { navigation: auto; }のみで有効化可能。Astro (標準モード) がネイティブに対応可能だが、状態保持などの高度な機能のためにClient Routerを併用することが多い。

この区分は、フレームワークの設計思想に直結します。Next.jsはSPAとしてSame-Document遷移を前提に設計されていますが、Astroは本質的にMPAでありながら、Cross-Document遷移のブラウザサポートが整うまでの過渡期、あるいはより高度な制御のために、Same-Document遷移を模倣するルーターを実装しています 1。

## Astroのアーキテクチャ分析としてDOM中心のアプローチ

Astroは「Islands Architecture」を標榜し、デフォルトでJavaScriptを排除するHTMLファーストのフレームワークです。しかし、View Transition APIをサポートするために導入された<ClientRouter />（旧称 <ViewTransitions />）コンポーネントは、Astroの動作原理を根本的に変容させます。これにより、Astroサイトは静的なMPAから、SPAのような挙動をする「ハイブリッド・ルーティング」アプリケーションへと変化します。

### Client Routerによるナビゲーションの乗っ取り

Astroの<ClientRouter />がページに含まれると、約3kb〜の軽量なスクリプトが注入され、サイト内の全ての内部リンク（<a>タグ）に対するクリックイベントをインターセプトします。ここでの処理フローは、Reactのような仮想DOM（VDOM）ベースのルーターとは根本的に異なります。

フェッチとパース (Fetch & Parse)

リンクがクリックされると、ルーターはpreventDefault()を実行し、遷移先URLのHTMLをfetch()で取得します。取得されたHTML文字列は、DOMParser APIを用いて解析され、メモリ上に新しいDocumentオブジェクト（newDoc）として展開されます。ここでのポイントは、サーバーから送られてくるのがJSONデータではなく、完全なHTMLドキュメントであるという点です。これはAstroがサーバーサイドでレンダリングを完結させていることを意味します。

スワップロジック (Swap Logic)

Astroは取得したnewDocと現在のdocumentを比較し、内容を入れ替えます。デフォルトの挙動は、document.bodyの総入れ替えです。

この豪快なアプローチにより、Astroはページ内のJavaScriptの状態管理を気にすることなく、サーバーで生成された最新のHTMLを即座に反映させることができます。しかし、単なる入れ替えでは画面のチラつきや状態の喪失が発生するため、ここでView Transition APIが活用されます。startViewTransitionのコールバック内でこのスワップを実行することで、ブラウザは入れ替え前後の状態を滑らかにつなぎ合わせます。

transition:persist によるDOMの移植手術

Astroのアーキテクチャにおいて最も特徴的かつ強力な機能が、transition:persistディレクティブです。通常、document.bodyを入れ替えれば、その中に含まれる<video>や<audio>、あるいは複雑なCanvas要素の状態はリセットされます。しかし、Astroは「DOMノードの物理的な移動」によってこれを回避します。

DOM移植のメカニズム。

スワップが実行される直前、Astroのルーターは現在のDOMからtransition:persist属性を持つ要素を検索します。見つかった要素は、DOMツリーから一時的に**切断（detach）**され、メモリ上のキャッシュ（Mapオブジェクトなど）に保存されます。この「切断」こそが重要です。DOMノードはドキュメントから外されても、そのインスタンス自体はJavaScriptメモリ上に生き続けており、再生中の動画ストリームやWebSocket接続などの内部状態を保持し続けます。

新しいボディが挿入された後、ルーターは新ドキュメント内で対応する要素（同じIDや遷移名を持つプレースホルダー）を探し出し、そのプレースホルダーをメモリ上に退避させておいた「生きたDOMノード」で置換します。

この手法は、Reactにおける「コンポーネントの状態保持（Reconciliationによる同一性の維持）」とは全く異なるアプローチです。Reactが「論理的な状態（State）」を維持してビューを再描画するのに対し、Astroは「物理的な要素（Element）」そのものを移植します。これにより、フレームワーク固有の状態管理ライブラリに依存せず、ブラウザネイティブの要素の状態を維持することが可能になります 7。

スクリプトのライフサイクルと「ソフトロード」の課題

Astroのようなアプローチ（HTMLスワップ）における最大の技術的課題は、スクリプトの実行管理です。通常のMPA遷移（ハードロード）では、ブラウザがメモリを一掃し、スクリプトを最初から実行します。しかし、Client Routerによる遷移（ソフトロード）では、windowオブジェクトやグローバルスコープが維持されます。

これにより、以下のような問題が発生しやすくなります：

イベントリスナーの重複。 window.addEventListenerなどが遷移のたびに再実行されると、リスナーが多重登録され、メモリリークや意図しない挙動を引き起こします。

変数の汚染。 グローバル変数がリセットされないため、古いページの状態が新しいページに影響を与える可能性があります。

初期化漏れ: 新しく挿入されたHTMLに含まれるインラインスクリプトは、ブラウザによって自動的に実行されない場合があります（innerHTMLやreplaceWithの仕様による）。

Astroはこの問題に対処するために、厳密なスクリプト管理ロジックを実装しています。

重複実行の防止。<script src="...">で読み込まれる外部モジュールについては、すでに読み込み済みのものを追跡し、再実行を防ぎます。

再実行の強制。インラインスクリプトや、data-astro-rerun属性が付与されたスクリプトは、スワップ後に明示的に再実行されます。

ライフサイクルイベント: astro:page-load、astro:after-swapといった独自のイベントを提供し、開発者が「ページ遷移ごと」に実行したい初期化処理を安全に記述できるフックを提供しています 7。

このアーキテクチャは、開発者に対して「MPAのメンタルモデル」と「SPAのライフサイクル管理」の両方を要求するため、従来のjQuery的な書き方とモダンなコンポーネント指向の中間のような独特のコーディングスタイルを必要とします。

Next.js (App Router) のアーキテクチャ分析として状態駆動と同時実行性の融合

Next.js、特にバージョン13以降のApp Routerは、React Server Components (RSC) を基盤とした、より複雑かつ高度に抽象化されたアーキテクチャを採用しています。ここでのView Transition APIの実装は、DOM操作ではなく、Reactのレンダリングサイクル（Render Phase & Commit Phase）との深い統合を意味します。

React Server Componentsと

Next.jsにおけるナビゲーションは、新しいHTMLを取得するプロセスではありません。それは、サーバーからRSC Payloadを取得し、クライアント側のReactツリーとReconcileするプロセスです。

ナビゲーショントリガー: ユーザーが<Link>をクリックするか、router.push()を呼び出すと、Next.jsはサーバーに対して該当ルートのRSCデータをリクエストします。

StreamingとSuspense。サーバーはコンポーネントツリーをシリアライズしたデータ形式（Flight）でストリーミング返却します。

クライアントでの展開: クライアント側のReactランタイムは、このデータを受け取り、既存のコンポーネントツリーの該当部分（例えばpage.jsの内容）を更新します。この際、layout.jsのような共通部分はアンマウントされず、そのまま維持されます。

この「差分更新」の仕組みは、Astroの「全置換」とは対照的です。Reactは変更が必要な最小限のDOMノードのみを操作しようとします。これがView Transition APIと組み合わさる際、独特の課題と利点を生みます。私はここが一番興味深かったです。

### React 19とuseViewTransitionによる同期

React 18で導入されたConcurrent Mode（同時実行モード）は、レンダリング処理を中断可能にし、メインスレッドのブロックを防ぐ革新的な機能でした。しかし、View Transition APIはstartViewTransitionのコールバック内で同期的にDOMが更新されることを期待します。もしReactがレンダリングを中断したり、非同期データ待ち（Suspense）に入ったりすれば、ブラウザは「更新が終わらない」と判断し、タイムアウトするか、意図しない状態でスナップショットを撮ってしまいます。

この不整合を解消するために、Next.js 15/16およびReact 19では、useViewTransitionフックや<ViewTransition>コンポーネントといった新しいプリミティブが導入されました。

トランジションのラップ。Reactの状態更新（setStateやナビゲーション）をstartViewTransitionでラップする際、Reactは内部的にスケジューリングを調整し、コミットフェーズ（実際にDOMを書き換える段階）がstartViewTransitionのコールバックと同期するように制御します。

Suspenseとの闘い。ナビゲーション先にデータ取得が必要な非同期コンポーネントがある場合、Reactは通常「ローディング状態（Suspense fallback）」を表示します。View Transition中にこれが発生すると、「旧ページ」→「ローディングスピナー」への遷移アニメーションが発生してしまいます。理想的な「旧ページ」→「新ページ」の遷移を実現するためには、データ取得が完了するまで現在の画面を維持（Paint Holding）する必要があります。Next.jsは、これを実現するためにRSCのプリフェッチや、ReactのstartTransition（UIをブロックせずにバックグラウンドで準備する機能）を活用しています 15。


### レイアウトの永続性とアニメーションのスコープ

Next.jsの強みは、layout.jsによるネストされたレイアウトシステムです。親レイアウトはナビゲーション間で永続化され、再レンダリングはされますがアンマウントはされません。

View Transition APIの観点からは、これは「DOMノードが変わらない」ことを意味します。したがって、レイアウト部分にアニメーションを適用したい場合（例えばヘッダーの背景色が変わるなど）、単にCSSクラスを変更するだけでは、View Transitionはそれを「同じ要素のスタイル変更」として扱います。これは通常望ましい挙動ですが、明示的に要素を置き換えたい場合や、異なる要素として遷移させたい場合には、keyプロパティを変更してReactに再マウントを強制するか、view-transition-nameを動的に切り替えるなどのテクニックが必要になります。

一方、Astroはデフォルトで全置換を行うため、共通ヘッダーであっても技術的には「新しいヘッダー要素」になります。これを滑らかにつなぐには、明示的に同じview-transition-nameを付与し、ブラウザに「これらは同じものである」と認識させる必要があります。Next.jsは「論理的に同じ」、Astroは「視覚的に同じ」として扱うアプローチの違いがここにあります 18。

## 比較分析：ネットワーク、パフォーマンス、DX

両フレームワークのアーキテクチャの違いは、実際のアプリケーションにおけるパフォーマンス特性や開発者体験（DX）に顕著に現れます。

ネットワークペイロードとレイテンシ。

指標Astro (Client Router)Next.js (App Router)影響と分析転送データ形式HTML文字列Flightデータ (シリアライズされたRSC)HTMLはブラウザにとってネイティブであり、パースが極めて高速。Flightデータは一度テキストとして受信し、クライアントのReactランタイムが解析・再構築する必要があるため、CPUコストが高い。JavaScript量極小 (アイランドのみ)大 (Reactランタイム + フレームワークコード)AstroはJS実行量が少ないため、低スペックデバイスでもstartViewTransitionの呼び出しからアニメーション開始までのラグが少ない。Next.jsはハイドレーションやリコンシリエーションのコストがかかる。プリフェッチ<a href>のリンク先HTMLをフェッチ<Link>のRSCペイロードをフェッチNext.jsのプリフェッチは非常にアグレッシブで高度だが、ペイロードサイズが大きくなりがち。Astroはシンプルだが、HTML全体を取得するため帯域幅を消費する場合がある。

分析: コンテンツ主体のサイト（ブログ、メディア、ドキュメント）において、Astroのアプローチは圧倒的な優位性を持ちます。View Transitionの待機時間（Freeze状態）は、次の画面の準備にかかる時間に直結します。AstroはHTMLをパースしてDOMに入れるだけなので、この時間が短く、遷移が「キビキビ」と感じられます。一方、Next.jsはRSCのデシリアライズとVDOM計算が必要なため、複雑なページでは「一瞬の硬直」が発生するリスクがあります 20。

### メモリ管理と状態の永続性

Next.js。Reactのコンポーネントツリー（Fiber）がメモリ上に常駐します。状態（useStateやContext）はJavaScriptのヒープ領域に存在します。遷移してもLayoutコンポーネントの状態は維持されます。これは、複雑なアプリケーション（ダッシュボードやSNS）において、ユーザーの入力内容やスクロール位置、開閉状態などを保持するのに極めて有利です。

Astro。基本的にページ遷移ごとにDOMベースの状態はリセットされます。transition:persistを使えばDOMノード単位での保持は可能ですが、アプリケーション全体の状態（例：認証状態やショッピングカート）を保持するには、nano storesのような外部ストアを利用し、かつページ遷移後も再接続されるような仕組みを自前で構築する必要があります。

### 技術的収束と発散

本分析により、Next.jsとAstroは、View Transition APIという同じ標準技術を利用しながらも、全く異なる哲学に基づいて実装を行っていることが明らかになりました。

Astroは、ブラウザのネイティブ動作の模倣を目指していルのではないでしょうか。HTMLスワップとDOM移植による実装は、将来的にブラウザがCross-Document View Transitionsを完全にサポートしたとき、Client Routerを削除してもそのまま動作する、あるいは最小限のポリフィルで済むような、ウェブ標準に寄り添った設計です。これは「過渡期の技術」としての賢明な実装と言えます。

Next.jsは、Reactエコシステムへの統合を目指していルように見えます。View TransitionをReactの状態遷移の一部として取り込み、SuspenseやServer Actionsと協調させることで、よりリッチな体験を追求しています。これはWeb標準を「素材」として使い、独自の高度なランタイム体験を構築する方向性です。
