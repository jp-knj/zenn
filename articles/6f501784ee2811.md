---
title: "View Transition APIを通じて見えてくるNext.jsとAstroのアーキテクチャ"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Next.js", "Astro"]
published: false
---

## はじめに

ウェブフロントエンド開発のエコシステムは成熟期を迎えました。長らくウェブ開発の議論を二分してきた「シングルページアプリケーション（SPA）」と「マルチページアプリケーション（MPA）」という二項対立は、View Transition APIの標準化と普及により、その境界線を溶解させています。

View Transition APIは、ページ遷移、要素の更新などのDOMの状態変化をブラウザがキャプチャし、新旧の状態間を補間するアニメーションを提供します。これにより、MPAであってもSPAのようなシームレスな体験を実装でき、SPAにおいては複雑なアニメーションライブラリに依存せず、宣言的な遷移アニメーションが実現できます。

この記事ではNext.js（App Router）とAstroに焦点を当て、各フレームワークがView Transition APIをどのように実装して統合しているかを解説します。View Transition APIという共通のレンズを通し、React Server Components（RSC）による「状態駆動型」と、Islands Architectureによる「DOM駆動型」、それぞれの根本的なアーキテクチャ思想の差異を明らかにすることをこの記事の目的とします。

## View Transition APIとは

Next.jsとAstroの実装を見る前に、その基盤となるブラウザのメカニズム、すなわちView Transition APIの仕様と動作原理を深く理解する必要があります。このAPIは単なるCSSの拡張ではなく、ブラウザのレンダリングに直接介入しています。

### ブラウザレンダリング

View Transition APIの核となるのは、`document.startViewTransition(callback)`メソッドです。このメソッドが呼び出されると、ブラウザはレンダリングループを一時停止し、厳密な手順を踏みます。

##### 1. 古い画面のキャプチャ

ブラウザは現在のviewportを画像化します。この際、`view-transition-name`CSSプロパティが付与された要素は個別にレイヤーとして切り出され、それ以外の部分は「root」スナップショットとしてキャプチャされます。この処理はメインスレッドとGPUプロセスが協調して行われ、現在の画面状態を完全に凍結します。

##### 2. レンダリングの凍結

ユーザーには古い状態のスナップショットが表示され続けます。この間、ブラウザはバックグラウンドでDOMの更新を待機します。フレームワークはこのタイミングでDOMを変更する処理を実行します。

##### 3. DOMの更新とコールバック実行

`startViewTransition`に渡されたコールバック関数が実行されます。このコールバックはPromiseを返すことが期待されており、そのPromiseが解決されるまでブラウザは待機します。

##### 4. 新しい画面のキャプチャ

コールバックが完了し、ブラウザが新しいDOMのレイアウト計算とペイントを終えると、再び画像化が行われます。これが「新しい状態」のスナップショットとなります。

##### 5. 疑似要素ツリーの構築とアニメーション

ブラウザは::view-transitionをルートとする特別な疑似要素ツリーをHTML要素の上にオーバーレイとして生成します。このツリーには、古いスナップショット`::view-transition-old`と新しいスナップショット`::view-transition-new`が含まれます。デフォルトでは、これらがクロスフェードしますが、CSSを用いて位置やサイズの遷移を定義することで、要素が移動しているような視覚効果を生み出します。

## Same-Document遷移とCross-Document遷移

仕様策定とブラウザ実装において、最も重要な区分が「Same-Document（単一ドキュメント）」と「Cross-Document（ドキュメント間）」の違いです。

機能区分技術的定義フレームワークの対応状況Same-Document View Transitions (Level 1)documentオブジェクトが破棄されず、JavaScriptによってDOMが書き換えられる遷移。SPAにおけるルーティング遷移がこれに該当します。

Next.js (App Router), Astro (Client Routerモード) が主に使用。JavaScriptによるAPI呼び出し(document.startViewTransition)が必須。Cross-Document View Transitions (Level 2)ブラウザが新しいURLへナビゲートし、documentが破棄されて新しいdocumentがロードされる遷移。MPAの標準的な遷移。CSSの`@view-transition { navigation: auto; }`のみで有効化可能。Astro (標準モード) がネイティブに対応可能だが、状態保持などの高度な機能のためにClient Routerを併用することが多い。

フレームワークの設計思想に直結します。Next.jsはSPAとしてSame-Document遷移を前提に設計されていますが、Astroは本質的にMPAでありながら、Cross-Document遷移のブラウザサポートが整うまでの過渡期、あるいはより高度な制御のために、Same-Document遷移を模倣するルーターを実装しています。

## Astroのアーキテクチャ分析としてDOM中心のアプローチ

Astroは「Islands Architecture」を標榜し、デフォルトでJavaScriptを排除するHTMLファーストのフレームワークです。しかし、View Transition APIをサポートするために導入された`<ClientRouter />`（旧称 `<ViewTransitions />`）コンポーネントは、Astroの動作原理を根本的に変えます。これにより、Astroサイトは静的なMPAから、SPAのような挙動をする「ハイブリッド・ルーティング」へと変化します。

### Client Routerによるナビゲーションの乗っ取り

Astroの`<ClientRouter />`がページに含まれると、約3kb〜の軽量なスクリプトが注入され、サイト内の全ての内部リンクに対するクリックイベントをインターセプトします。ここでの処理フローは、React Elementベースのルーターとは根本的に異なります。

#### FetchとParse

リンクがクリックされると、ルーターは`preventDefault()`を実行し、遷移先URLのHTMLを`fetch()`で取得します。取得されたHTML文字列は、DOMParser APIを用いて解析され、メモリ上に新しいDocumentオブジェクト（newDoc）として展開されます。ここでのポイントは、サーバーから送られてくるのがJSONデータではなく、「完全なHTMLドキュメントである」という点です。これはAstroがサーバーサイドでレンダリングを完結させていることを意味します。

#### Swap Logic

Astroは取得したnewDocと現在のdocumentを比較し、内容を入れ替えます。デフォルトの挙動は、`document.body`の総入れ替えです。

このアプローチにより、Astroはページ内のJavaScriptの状態管理を気にしません。サーバーで生成された最新のHTMLを即座に反映させることができます。しかし、単なる入れ替えでは画面のチラつきや状態の喪失が発生するため、ここでView Transition APIが活用されます。`startViewTransition`のコールバック内でこの入れ替えを実行することで、ブラウザは入れ替え前後の状態を滑らかにつなぎ合わせます。

`transition:persist`によるDOMの移植手術

Astroのアーキテクチャにおいて最も特徴的かつ強力な機能が、`transition:persist`ディレクティブです。通常、document.bodyを入れ替えれば、その中に含まれる<video>や<audio>、あるいは複雑なCanvas要素の状態はリセットされます。しかし、Astroは「DOMノードの物理的な移動」によってこれを回避します。

DOM移植のメカニズム。

スワップが実行される直前、Astroのルーターは現在のDOMからtransition:persist属性を持つ要素を検索します。見つかった要素は、DOMツリーから一時的に切断され、メモリ上のキャッシュ（Mapオブジェクトなど）に保存されます。この「切断」こそが重要です。DOMノードはドキュメントから外されても、そのインスタンス自体はJavaScriptメモリ上に生き続けており、再生中の動画ストリームやWebSocket接続などの内部状態を保持し続けます。

新しいbodyが挿入された後、ルーターは新ドキュメント内で対応する要素（同じIDや遷移名を持つプレースホルダー）を探し出し、そのプレースホルダーをメモリ上に退避させておいた「生きたDOMノード」で置換します。

この手法は、Reactにおける「コンポーネントの状態保持（Reconciliationによる同一性の維持）」とは全く異なるアプローチです。ReactがStateを維持してビューを再描画するのに対し、Astroは「物理的な要素（Element）」そのものを移植します。これにより、フレームワーク固有の状態管理ライブラリに依存せず、ブラウザネイティブの要素の状態を維持することが可能になります。

スクリプトのライフサイクルと「ソフトロード」の課題

Astroのようなアプローチにおける最大の技術的課題は、スクリプトの実行管理です。MPA遷移（hard load）では、ブラウザがメモリを一掃し、スクリプトを最初から実行します。しかし、Client Routerによる遷移(Soft load）では、windowオブジェクトやグローバルスコープが維持されます。

これにより、以下のような問題が発生しやすくなります。

イベントリスナーの重複。 window.addEventListenerなどが遷移のたびに再実行されると、リスナーが多重登録され、メモリリークや意図しない挙動を引き起こします。

変数の汚染。 グローバル変数がリセットされないため、古いページの状態が新しいページに影響を与える可能性があります。

初期化漏れ。新しく挿入されたHTMLに含まれるインラインスクリプトは、ブラウザによって自動的に実行されない場合があります（innerHTMLやreplaceWithの仕様による）。

Astroはこの問題に対処するために、厳密なスクリプト管理ロジックを実装しています。

重複実行の防止。<script src="...">で読み込まれる外部モジュールについては、すでに読み込み済みのものを追跡し、再実行を防ぎます。

再実行の強制。インラインスクリプトや、data-astro-rerun属性が付与されたスクリプトは、スワップ後に明示的に再実行されます。

ライフサイクルイベント: astro:page-load、astro:after-swapといった独自のイベントを提供し、開発者が「ページ遷移ごと」に実行したい初期化処理を安全に記述できるフックを提供しています。

このアーキテクチャは、開発者に対して「MPAのメンタルモデル」と「SPAのライフサイクル管理」の両方を要求するため、従来のjQuery的な書き方とモダンなコンポーネント指向の中間のような独特のコーディングスタイルを必要とします。

## Next.js (App Router) のアーキテクチャ分析として状態駆動と同時実行性

Next.js、特にバージョン13以降のApp Routerは、React Server Components (RSC) を基盤とした、より複雑かつ高度に抽象化されたアーキテクチャを採用しています。ここでのView Transition APIの実装は、DOM操作ではなく、Reactのレンダリングサイクル（Render Phase & Commit Phase）との統合です。

### React Server Components

Next.jsにおけるナビゲーションは、新しいHTMLを取得するプロセスではありません。それは、サーバーからRSC Payloadを取得し、クライアント側のReactツリーとReconcileするプロセスです。

// 「ここをこう変更してね」という『設計図（RSC Payload）』 をサーバーからもらいます。 ブラウザはその設計図を見ながら、今の部屋と見比べて、違う部分だけを書き換えます。

ナビゲーショントリガー。ユーザーが<Link>をクリックするか、router.push()を呼び出すと、Next.jsはサーバーに対して該当ルートのRSCデータをリクエストします。

StreamingとSuspense。サーバーはコンポーネントツリーをシリアライズしたデータ形式（Flight）でストリーミングを返します。

Streaming.サーバーは、材料を一度に全部送るのではなく、準備できたものから順番に送ってきます。 「畳が届くまでは、とりあえず『準備中』の看板（スケルトン表示など）を出しておいて」というのが Suspense です。 ちなみに、この材料はトラックで運びやすいように 「Flight」という特殊な形式 に圧縮・梱包されています。

クライアントでの展開。クライアント側のReactランタイムは、このデータを受け取り、既存のコンポーネントツリーの該当部分（例えばpage.jsの内容）を更新します。この際、layout.jsのような共通部分はアンマウントされず、そのまま維持されます。

この「差分更新」の仕組みは、Astroの「全置換」とは対照的です。

Reactは変更が必要な最小限のDOMノードのみを操作しようとします。これがView Transition APIと組み合わさるとき、独特の課題と利点を生みます。
私はここが一番興味深いなと感じたポイントです。

### React 19とuseViewTransitionによる同期

React 18で導入されたConcurrent Modeは、レンダリング処理を中断できるようになりました。メインスレッドのブロックを防ぐ機能でした。しかし、View Transition APIは`startViewTransition`のコールバック内で同期的にDOMが更新されることを期待します。もしReactがレンダリングを中断したり、非同期データ待ち（Suspense）が発生すると、ブラウザは「更新が終わらない」と判断し、タイムアウトするか、崩れた状態でスナップショットを撮ってしまいます。

この不整合を解消するために、Next.js 15、16およびReact 19では、`useViewTransition`フックや`<ViewTransition>`コンポーネントといった新しいプリミティブが導入されました。

// トランジションのラップ。Reactの状態更新（setStateやナビゲーション）を`startViewTransition`でラップするとき、Reactは内部的にスケジューリングを調整し、コミットフェーズ（実際にDOMを書き換える段階）がstartViewTransitionのコールバックと同期するように制御します。

ReactがDOMを書き換えるタイミングを勝手に決めれません。ブラウザが指定したコールバック）の中に強制的にねじ込まないといけないのです。

Suspenseとの闘い。ナビゲーション先にデータ取得が必要な非同期コンポーネントがあるとき、Reactは「ローディング状態（Suspense fallback）」を表示します。View Transition中にSuspenseが発生すると、「古いページ」→「ローディングスピナー」への遷移アニメーションが発生してしまいます。理想的な「古いページ」→「新しいページ」の遷移を実現するためには、データ取得が完了するまで現在の画面を維持（Paint Holding）する必要があります。Next.jsは、これを実現するためにRSCのprefetchや、ReactのstartTransition（UIをブロックせずにバックグラウンドで準備する機能）を活用しています。

### レイアウトの永続性とアニメーションのスコープ

Next.jsの強みは、layout.jsによるネストされたレイアウトシステムです。親レイアウトはナビゲーション間で永続化され、再レンダリングはされますがアンマウントはされません。

View Transition APIの観点からは、これは「DOMノードが変わらない」ことを意味します。したがって、レイアウト部分にアニメーションを適用したいとき（例えばヘッダーの背景色が変わるなど）、単にCSSクラスを変更するだけでは、View Transitionを「同じ要素のスタイル変更」として扱います。これは望ましい挙動ですが、明示的に要素を置き換えたいときや、異なる要素として遷移させたいときには、keyプロパティを変更してReactに再マウントを強制するか、view-transition-nameを動的に切り替えるなどのテクニックが必要になります。

一方、Astroはデフォルトで全置換を行うため、共通ヘッダーであっても技術的には「新しいヘッダー要素」になります。これを滑らかにつなぐには、明示的に同じview-transition-nameを付与し、ブラウザに「これらは同じものである」と認識させる必要があります。Next.jsは「論理的に同じ」、Astroは「視覚的に同じ」として扱うアプローチの違いがここにあります。

## 比較分析

両フレームワークのアーキテクチャの違いは、実際のアプリケーションにおけるパフォーマンス特性や開発者体験（DX）に顕著に現れます。
ネットワークペイロードとレイテンシ。

指標Astro (Client Router)Next.js (App Router)影響と分析転送データ形式HTML文字列Flightデータ (シリアライズされたRSC)
HTMLはブラウザにとってネイティブであり、パースが極めて高速。Flightデータは一度テキストとして受信し、クライアントのReactランタイムが解析・再構築する必要があるため、CPUコストが高い。JavaScript量極小 (アイランドのみ)大 (Reactランタイム + フレームワークコード)AstroはJS実行量が少ないため、低スペックデバイスでもstartViewTransitionの呼び出しからアニメーション開始までのラグが少ない。Next.jsはhydrationやReconciliationのコストがかかる。prefetch<a href>のリンク先HTMLをフェッチ<Link>のRSC　Payloadをfetch。
Next.jsのprefetchはアグレッシブで高度だが、ペイロードサイズが大きくなりがち。
Astroはシンプルだが、HTML全体を取得するため帯域幅を消費する場合がある。

コンテンツ主体のサイト（ブログ、メディア、ドキュメント）において、Astroのアプローチは圧倒的な優位性を持ちます。View Transitionの待機時間（Freeze状態）は、次の画面の準備にかかる時間に直結します。AstroはHTMLをパースしてDOMに入れるだけなので、この時間が短く、遷移が「キビキビ」と感じられます。一方、Next.jsはRSCのデシリアライズとVDOM計算が必要なため、複雑なページでは「一瞬の硬直」が発生するリスクがあります。

### メモリ管理と状態の永続性

Next.js。Reactのコンポーネントツリー（Fiber）がメモリ上に常駐します。状態（useStateやContext）はJavaScriptのヒープ領域に存在します。遷移してもLayoutコンポーネントの状態は維持されます。これは、複雑なアプリケーション（ダッシュボードやSNS）において、ユーザーの入力内容やスクロール位置、開閉状態などを保持するのに極めて有利です。

Astro。基本的にページ遷移ごとにDOMベースの状態はリセットされます。transition:persistを使えばDOMノード単位での保持は可能ですが、アプリケーション全体の状態（例：認証状態やショッピングカート）を保持するには、nano storesのような外部ストアを利用し、かつページ遷移後も再接続されるような仕組みを自前で構築する必要があります。

### 技術的収束と発散

Next.jsとAstroは、View Transition APIという同じ標準技術を利用しながらも、全く異なる哲学に基づいて実装を行っていることが理解できたのではないでしょうか。

Astroは、ブラウザのネイティブ動作の模倣を目指していルのではないでしょうか。HTML置換とDOM移植による実装は、将来的にブラウザがCross-Document View Transitionsを完全にサポートしたとき、Client Routerを削除してもそのまま動作する、あるいは最小限のポリフィルで済むようなウェブ標準に寄り添った設計です。これは「過渡期の技術」としての賢明な実装と言えます。

Next.jsは、Reactエコシステムへの統合を目指していルように見えます。View TransitionをReactの状態遷移の一部として取り込み、SuspenseやServer Actionsと協調させることで、コンポーネント単位でリッチな体験を追求しています。これはウェブ標準を「素材」として使い、独自の高度なランタイム体験を構築する方向性です。
