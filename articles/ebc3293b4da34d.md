---
title: "あー、Astro Intergrationはこれがオススメっすね"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["astro", "vercel", "cloudflare"]
published: true
---

## はじめに

Astro v5を経て、フレームワークは「コンテンツ駆動」を軸にしながらも、動的なコンテンツを安全に足せるプラットフォームへと進化してきました。しかし、機能が増えたぶん、最初に何を入れるかで迷いやすくなっています。

本記事ではその迷いを解消するために、新規プロジェクトで環境構築するなら私は、これを選ぶというAstro Integration（と周辺ツール）をまとめました。

判断基準は以下の3つだけに絞っています。
1. 配信サイズを小さくすること（Less JavaScript）
2. 運用の複雑さを抑えること（Simple Ops）
3. 必要十分な拡張余地を残すこと

## アーキテクチャの要

まず、すべての土台となるアーキテクチャを決定します。 基本戦略は静的中心のサイトはZero JSを起点にし、動的要件はServer Islandsで吸収する感じでしょうか

### なぜServer Islandsなのか

従来のAstro（SSG）は、ビルド時にすべてのHTMLを生成して終わりでした。しかし、動的要素が1つあるだけで、ページ全体をSSR（サーバーサイドレンダリング）にする必要があり、キャッシュ効率が落ちていました。

[Server Islands](https://docs.astro.build/en/guides/server-islands/)はこの問題を解決します。ページ全体は静的HTMLとしてCDNにキャッシュしつつ、動的な部分だけを後から非同期にサーバーでレンダリングして差し込む技術です。

### Adapterの導入

Server Islandsはリクエストを受け取ってロジックを動かす計算リソース（Server/Edge）を必要とします。そのため、デプロイ先に合わせたAdapterの導入が必須です。

[@astrojs/cloudflare](https://docs.astro.build/en/guides/integrations-guide/cloudflare/)。Edgeで速配信ならこれ。
[@astrojs/vercel](https://docs.astro.build/en/guides/integrations-guide/vercel/)。ISRや画像最適化など機能豊富ですね。

「Server Islandsを採用する ＝ 静的ホスティングを卒業し、Adapterを入れる」という等式が成立します。

## UIランタイムを選ぶ

UIランタイムにこだわりがないのであれば、独断ですが`@astrojs/svelte`と`@astrojs/alpinejs`をおすすめします。

 [@astrojs/svelte](https://docs.astro.build/en/guides/integrations-guide/svelte/)
Svelteはコンパイルベースであり、ランタイムサイズが他のUIランタイムと比べて小さいです。初期ロード時間を削りたいメディアサイトや、軽量なインタラクションが必要な場合、私はこれを選びます。AstroのHTMLファーストな思想と相性が良いです。具体的には、次のようなユースケースで使いやすいと感じています。

- 埋め込む関連コンテンツのカルーセル
- フィードバックフォームやメール購読フォームなど、1画面で完結するフォームUI
- フィルタリング・ソートが必要な一覧UI

SPAほどの複雑さは不要だが、ちょっとした状態管理を伴うUIを、できるだけ小さいJSで届けたい場面で、Svelteはちょうどよい落としどころになります。

[@astrojs/alpinejs](https://docs.astro.build/en/guides/integrations-guide/alpinejs/)
JavaScript　bundleを増やさずに、クラス名の操作や開閉などのDOM操作の延長として使えます。Astroのコンポーネントの志向と実DOM操作のちょうど良い間の使い心地です。

ユースケースとしては、
- ヘッダーナビゲーションの開閉
- FAQページのアコーディオン
- シンプルなタブ切り替え
- フィルタ条件のオン・オフ程度で済む、絞り込みUI

Alpine.jsは主要なUIランタイムを導入するほどではないが、素のHTML＋CSSだけでは少し物足りない部分です。Alpine.jsであれば、ほんの数行足すだけで実現でき、JavaScriptをあまり増やさずに済みます。

もちろん、[React](https://docs.astro.build/en/guides/integrations-guide/react/) や [Vue](https://docs.astro.build/en/guides/integrations-guide/vue/)、[Solid](https://docs.astro.build/en/guides/integrations-guide/solid/) など、チームが慣れ親しんだツールを選ぶのも良いでしょう。どれを選んでも動きますが、「まずは軽量に始めたい」「Zero JS 起点を崩したくない」という場合は、`@astrojs/svelte`と`@astrojs/alpinejs`を優先して検討すると良いと考えています。

## Content Layer API

データ取得は、各ページでバラバラに行うのではなく、 [Content Layer API](https://astro.build/blog/astro-4140/?utm_source=newsletter.astroweekly.dev&utm_medium=referral&utm_campaign=astro-weekly-44#experimental-content-layer-api)に集約します。

おすすめは、[microcms-js-sdk](https://github.com/microcmsio/microcms-js-sdk) でしょうか。Loaderはデータの取得、検証、キャッシュ、および更新のロジックをカプセル化し、外部データをローカルコンテンツと同様に型安全な状態で扱うことができるので、CMS側がライブラリを提供しているか確認したいところです。

## 画像の最適化

基本は`astro:assets`です。これだけで十分です。

- ビルド時にWebP/AVIFへ自動変換。
- width / height を自動検出し、CLS（レイアウトシフト）を防止。
- `<img>`タグの代わりに`<Image />`コンポーネントを使うだけで、Lazy Loadingやレスポンシブ画像（srcset）を生成。

### 大規模なら外部CDNへ

`astro:assets`はビルド時に画像処理を行うため、画像が数千枚を超えるとビルド時間が長くなります。 そんなときは、packagesとして [Cloudinary](https://docs.astro.build/en/guides/media/cloudinary/)やImgixだと[unpic-img](https://unpic.pics/)などのライブラリを組み合わせて使うかあるいは自前の画像サーバーへ切り替えましょう。Astro側ではURL生成のみを行うアプローチにすれば、ビルド時間を犠牲にせず運用できます。

## SEO、マーケティング、計測の自動化

* [@astrojs/sitemap](https://docs.astro.build/en/guides/integrations-guide/sitemap/)
    * ビルドされたページ構造から`sitemap.xml`を自動生成します。Google Search Consoleへの登録に不可欠です。
* [astro-seo](https://github.com/jonasmerlin/astro-seo)
    * 全ページ共通のデフォルト設定（Default SEO）と、個別ページの上書き設定を分離管理できます。「OGP画像の指定漏れ」などを防ぐのに役立ちます。
* [@astrojs/partytown](https://docs.astro.build/en/guides/integrations-guide/partytown/)
    * Google AnalyticsやGTMなどの重いサードパーティスクリプトをWeb Workerに逃がし、メインスレッドのパフォーマンスを守ります。

## 開発者体験と品質保証

* [astro-auto-import](https://www.npmjs.com/package/astro-auto-import): 特定ディレクトリのコンポーネントをグローバル化し、import文の記述を省略します。
* [Sonda](https://sonda.dev): Astroにだけではないのですが、ビルド成果物のバンドルサイズを可視化します。「どのライブラリが容量を食っているか」を一目で特定できます。

* [eslint-plugin-astro](https://www.npmjs.com/package/eslint-plugin-astro): `.astro`ファイル内の検証や、画像のalt属性欠落などを検知します。Biomeベースの環境でも、Astro固有のルール適用（directives）に併用するのがおすすめです。もし使うなら、スターも一緒につけておいてもバチは当たりません。

### テスト戦略

Astro固有だと、これらを使ってます。

[Astro Container API（出力結果の検証）](https://docs.astro.build/en/reference/container-reference/)
  * 「特定のpropsで正しいクラスが付与されるか」「条件分岐でタグが消えるか」といった静的な構造のテストに最適です。早いです。

[Vitest Browser Mode（振る舞いの検証）](https://github.com/ascorbic/vitest-browser-astro/)
  * Container APIでは検証できないブラウザ上の挙動を担当します。
  * コンポーネントが正しくマウントされたか、スクロールイベントが発火したか、CSSの `display: none` が効いているか等は、こちらで検証します。

## さいごに

Astroは何でもできるがゆえに迷いやすいですが、このスタックを軸にしてみましょう。ブログから軽度なウェブアプリまで快適に開発できるはずです。それでは、良いAstroライフを！
