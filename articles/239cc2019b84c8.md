---
title: "Rolldownのモジュールローダーと依存グラフを読み解く――Rust製バンドラが切り拓くViteの次章"
emoji: "🦀"
type: "tech"
topics: ["rolldown", "vite", "rust", "rollup", "javascript"]
published: false
---

# はじめに

Viteでの開発体験は快適そのものです。しかし、`npm run dev`では完璧に動いていたはずのアプリケーションが、`npm run build`で本番用にビルドすると、なぜかスタイルが崩れたり、一部の機能が期待通りに動かなくなったりする……。そんな経験に、あなたも一度は頭を悩ませたことがあるかもしれません。私もその一人でした。開発サーバーと本番ビルドのアウトプットが微妙に異なることで、原因究明に多大な時間を費やすことがありました。この問題の根源は、Viteが開発時にはesbuildを、本番ビルドにはRollupを利用するという、特性の異なる2つのツールを使い分けている点にあります。この“二刀流”こそがViteの高速な開発サーバーを実現しているのですが、同時に、その境界で挙動の不整合という副作用を生んでいたのです。このギャップを埋めるべく、より一貫性のあるツールチェーンを模索し始めたとき、私の目に飛び込んできたのが、Rust製のフロントエンドツール群の台頭でした。TurbopackやRspackなど、パフォーマンスと堅牢性を両立するRust製バンドラが次々と登場する中で、Viteの未来として本命視されているのが、今回ご紹介する「Rolldown」です。Viteチーム自らが開発を主導し、Rollup互換のAPIを持ちながら、単一のエンジンで開発と本番の両方を担うことを目指しています。このRolldownのアーキテクチャを理解することこそ、Viteが迎える次のチャプターを読み解く鍵だと確信し、筆を執ることにしました。

---

# Rolldownのビルドプロセスを旅する

Rolldownの仕事は、一つの大きな旅のように、いくつかの連続したフェーズを経て完結します。旅の始まりは、プロジェクトの全体像を把握する**依存グラフの構築**です。エントリーポイントから出発し、`import`文を道しるべにすべてのファイルを訪ね、それらの関係性を一枚の地図に描き出します。地図が完成すると、旅は次の目的地である**最適化**へと進みます。ここでは地図を精査し、不要な脇道（使われていないコード）を消したり、効率的な近道（チャンク分割）を見つけたりします。旅のクライマックスは、**コード生成とバンドル**です。最適化された地図に基づき、各モジュールが最終的な目的地（ESモジュールやCommonJSなど）に合わせた形式でまとめ上げられます。そして旅の終わり、**出力**の段階で、完成したバンドルが開発サーバーのメモリ上、あるいは本番用のファイルとしてディスクに書き出され、私たちの手元に届けられるのです。

この旅路の中でも、最初の「依存グラフ構築」は全体の土台となる極めて重要なステップです。ここで正確かつ効率的な地図を作れなければ、その後の最適化も正しく機能しません。

---

# すべての始まり、モジュールローダー

依存グラフを構築するという重要な役割を担うのが、モジュールローダーです。その仕事は、あらゆるファイルを見つけ出し、読み込み、Rolldownが扱える内部構造へと変換することにあります。対象はJavaScriptやTypeScriptだけでなく、CSSや画像ファイルにまで及び、それぞれの種類に応じたパーサーや変換処理が適用されます。

この一連の処理は、`scan`関数から呼び出される`fetch_modules`という関数によって巧みにオーケストレーションされています。まず、ユーザーが指定したエントリーポイントのパスが`ResolvedId`という内部表現に解決され、`try_spawn_new_task`関数に渡されます。これにより、Tokioのランタイム上で並列実行される非同期タスクが生成されるのです。各タスクはファイルの読み込みや解析を進めながら、その進捗をMPSCチャネルを通じてメインプロセスに報告します。「新しい`import`先を見つけた」「ファイルの解析が終わった」といったメッセージを受け取るたびに、メインプロセスは必要に応じて新しいタスクをキューに追加していきます。この仕組みにより、I/Oで待機する時間とCPUで解析する時間を最大限に重ね合わせ、マルチコアCPUの性能を限界まで引き出すのです。すべてのタスクが完了し、チャネルが閉じられると、最終的なモジュール集合と依存グラフが完成し、旅の次のステップへと渡されます。

この複雑な処理を効率的に管理するため、Rolldownはいくつかの巧妙なデータ構造を駆使します。例えば、各モジュールは`ModuleIdx`という単純な数値IDで効率的に管理され、それらを格納する`HybridIndexVec`は、ビルドの種類に応じて内部実装を切り替える最適化が施されています。また、`ScanStageCache`は直前のビルド結果をスナップショットとして保持し、差分のみを再スキャンすることで、開発時の再ビルドを劇的に高速化するのです。

---

# 依存グラフが持つ二つの顔

Rolldownの設計で特に興味深いのは、依存グラフを**前方**と**後方**の二つの側面から同時に生成する点です。

前方グラフは、各モジュールが「どのファイルを`import`しているか」という関係性を、`ecma_view.import_records`のようなフィールドに保持します。これはバンドル対象のファイルや実行順序を決定するための基本的な地図となります。

その一方で、後方（あるいは逆）グラフは、「このモジュールは、どのファイルから参照されているか」という情報を`importers`のようなテーブルで管理します。この逆引きの地図は、特定のコードが本当に必要かどうかを判断する**ツリーシェイキング**や、ファイル変更時に影響範囲を最小限に抑える**HMR（ホットモジュールリプレイスメント）**といった、高度な最適化を実現するために不可欠です。

---

# パフォーマンスを支えるRustの力

Rolldownの驚異的なパフォーマンスは、その設計思想の根底にある二つの柱によって支えられています。一つは、Tokioランタイムを駆使した徹底的な**非同期での並列処理**です。これにより、ネットワークやファイルといったI/Oの待ち時間を、CPUが行う解析処理の裏で進行させ、システム全体のスループットを最大化します。

もう一つの柱は、**キャッシュとインクリメンタル（増分）処理**の積極的な活用です。直前のビルド結果をスナップショットとして保持し、変更が加えられたファイルとその影響範囲だけを再計算することで、開発時の再ビルド体験を劇的に向上させているのです。

これらの高度な最適化が、実行時の追加コストをほとんど生むことなく実現できているのは、まさにRust言語が持つゼロコスト抽象化と所有権モデルの賜物と言えるでしょう。

---

# Vite統合がもたらす未来

現在も活発に開発が進むRolldownですが、その最終目標の一つはViteへの完全統合です。Viteが正式にRolldownへとスイッチした暁には、私たちの開発体験は大きく変わるでしょう。

まず、長年の課題であった**開発環境と本番環境のビルド結果の差異が完全に解消**されます。また、Node.jsのシングルスレッドという制約から解放されることで、CI/CDにおけるビルド時間の大幅な短縮も期待できます。そして、この移行は**Rustネイティブプラグインという新たなエコシステムの開花**を促すかもしれません。

既存のViteプラグインを開発している方々は、今のうちからesbuildやRollupの特定機能に過度に依存しない、よりポータブルな実装を意識しておくことで、この大きな変化の波にスムーズに乗ることができるはずです。

---

# まとめ

Rolldownのモジュールローダーは、Tokioによる非同期実行と、Rustの特性を活かした巧妙なデータ構造を組み合わせることで、「依存グラフの構築」というビルドプロセスで最も重要なタスクを、現代のマルチコアCPU時代にふさわしい形で解決しています。

ViteがRolldownに一本化されれば、「開発では動いたのに、本番でビルドしたら壊れた」という、多くの開発者が経験してきた日常的なフラストレーションから解放されます。そして、フロントエンドのエコシステム全体のベースライン性能も大きく底上げされることになるでしょう。Rust製ツールチェーンがもたらすこの大きな波に備え、今のうちにその内部構造を覗いておくことには、計り知れない価値があるはずです。

---

> **参考**
> *Original article: “How Rolldown Works: Module Loading, Dependency Graphs, and Optimization Explained” by Atriiy.dev*
> 2025-04-12 公開。全文は以下から閲覧できます。
> https://www.atriiy.dev/blog/rolldown-module-loader-and-dependency-graph